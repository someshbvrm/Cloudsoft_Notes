Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. This page describes the commands you can use in a Dockerfile.

Key points:

    The name of the file must be "Dockerfile" (exact spelling, no extension)

    In one directory, we can keep only one Dockerfile. If we need 10 microservices we need to create 10 directories

We can build images from a Dockerfile using these commands:

    docker build -t myimage:tag .	#Builds from current directory

    docker build -t newimage:tag /home/ubuntu/microservice/	#Builds from specified path.  Usually we go to the path and use .

    docker build -t mytomcat:latest .	#Builds with just a name tag


-------------------------------------------------------------------------------------------
Dockerfile Instructions:
-------------------------------------------------------------------------------------------

Base Instructions:
FROM - Sets the base image for subsequent instructions
RUN - Executes commands in a new layer during image build
CMD - Provides default command/parameters for the container
LABEL - Adds metadata to the image
EXPOSE - Documents which ports the container listens on

Configuration Instructions:
ENV - Sets environment variables
ARG - Defines build-time variables
WORKDIR - Sets the working directory
USER - Sets the username/UID for subsequent commands
SHELL - Overrides default shell for RUN/CMD/ENTRYPOINT

File Operations:
COPY - Copies files/directories (preferred for simple copies)
ADD - Copies files/URLs and extracts archives automatically

Execution Control:
ENTRYPOINT - Configures the container to run as an executable
VOLUME - Creates a mount point for external volumes

Advanced Instructions:
ONBUILD - Adds trigger instructions for downstream builds
STOPSIGNAL - Sets the system call signal for stopping container
HEALTHCHECK - Defines how to test container health

Deprecated:
MAINTAINER - Sets the author field (use LABEL instead)

Each instruction serves a specific purpose in building efficient and secure Docker images. The COPY instruction is generally preferred over ADD for better transparency, unless you specifically need ADD's auto-extraction or URL capabilities.

---------------------------------------------------------------------------------------------

SAMPLE APACHE TOMCAT DOCKERFILE using official tomcat base image "tomcat:9.0-jdk17-openjdk"
---------------------------------------------------------------------------------------------

# Use official Tomcat image with JDK as base
FROM tomcat:9.0-jdk17-openjdk

# Set maintainer label (metadata)
LABEL maintainer="your.email@example.com"

# Remove default Tomcat apps (optional)
RUN rm -rf /usr/local/tomcat/webapps/ROOT*

# Copy custom configuration files
COPY conf/server.xml /usr/local/tomcat/conf/
COPY conf/context.xml /usr/local/tomcat/conf/

# Deploy WAR file (replace 'your-app.war' with actual filename)
COPY target/your-app.war /usr/local/tomcat/webapps/ROOT.war

# Create a volume for logs and temp files
VOLUME ["/usr/local/tomcat/logs", "/usr/local/tomcat/temp"]

# Expose Tomcat default port
EXPOSE 8080

# Set environment variables
ENV CATALINA_OPTS="-Xms512m -Xmx1024m"

# Health check (HTTP endpoint verification)
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/ || exit 1

# Start Tomcat
CMD ["catalina.sh", "run"]

-----------------------------------------------------------

Build Command:

docker build -t my-tomcat-app .

Run Command:

docker run -d -p 8080:8080 --name tomcat-container my-tomcat-app

---------------------------------------------------------

Check this tutorial --> https://www.middlewareinventory.com/blog/docker-tomcat-example-dockerfile-sample/

------------------------------------------------------------

In the same project we may have frontend microservices developed using reactjs or angularjs
and backend code may be developed using springboot or nodejs or dotnet or python

python have their own framworks using django

-------------------------------------------------------------------
Springboot:
-------------------------------------------------------------------
FROM openjdk:8-jdk-alpine
MAINTAINER info@cloudsoftsol.com
COPY target/docker-message-server-1.0.0.jar message-server-1.0.0.jar
ENTRYPOINT ["java","-jar","/message-server-1.0.0.jar"]

----------------------------------------------------------------------------------
Nodejs Dockerfile
-----------------------------------------------------------------------------
# Create app directory
WORKDIR /usr/src/app

# Install app dependencies
# A wildcard ensures both package.json AND package-lock.json are copied
COPY package*.json ./

RUN npm install
# For production:
# RUN npm ci --only=production

# Bundle app source.
COPY . .

EXPOSE 8080
CMD ["node", "server.js"]

--------------------------------------------------------------------------------------------------------------
docker build -t node-app .
docker run -p 8080:8080 node-app

--------------------------------------------------------------------------------------------------------
Note: Meaning of COPY . .

   	 First .

      	  	Refers to all files/folders in the current directory (where you're running docker build)

        	This is the build context (local files to be copied into the image)

    	Second .

      		Refers to the current working directory (WORKDIR) inside the container

       		Example: If WORKDIR /usr/src/app is set, files are copied to /usr/src/app/

-------------------------------------------------------------------------------------------------------

Python Dockerfile
---------------------------------------------------------------------------------------------------

# Use official Python runtime as base image
FROM python:3.9-slim  # Updated to current LTS version

# Set working directory
WORKDIR /app

# Install dependencies first (for better layer caching)
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt  # Added --no-cache-dir to reduce image size

# Copy application code
COPY src/ .  # Explicit trailing slash for clarity

# Expose port (documentation only - actual publishing happens at runtime)
EXPOSE 8080

# Run the application
CMD ["python", "server.py"]  # Using exec form for proper signal handling

------------------------------------------------------------------------------------------

docker build -t python-app .
docker run -p 8080:8080 python-app
---------------------------------------------------------------------------------------------


