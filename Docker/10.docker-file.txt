Dockerfiles are used to create our own images with set of Instructions.

Structure:

OS level base images

My code or My build
settings
certificates
environments
ports

If we have 12 microservices, we need to write 12 Dockerfiles. We need to create 12 directories to keep those Dockerfiles


To build the image
docker build -t imagename:tag

docker build -t myimage:1.1 . 	# [space]. means Dockerfile is in current working directory

docker build -t mynewimage:1.1 microservice1/

docker build -t mynewimage:1.1 microservice1/	#Image takes tag as latest

To create container from the image

docker run --name mytomcat -p 8084:8080 -d mynewimage:1.1

-------------------------------------------------------------------------------------------
Creating Dockerfile

FROM image	#OS images(alpline, ubuntu, centos) or Base images(nginx/MySQL/OpenJDK/tomcat)

MAINTAINER "Name or EmailID"	#deprecated

RUN		#It will run the commands on top of OS image of Docker image

--------------------------------------------------------------------------------------------

FROM centos

RUN "yum update && yum install httpd -y"	#Each run commands adds layers. So increases the image size

WORKDIR 	#commands or files will execute or copy to that working directory

COPY and ADD	#to copy war, jar or .js files into the working directory of image

COPY . .	#to copy all local files inside the image working directory

COPY target/*.war .	# to copy the war files in target folder to the image working directory

ADD		#we can copy from remote url. It automatically extracts tar files but COPY is recommended as copying from remote URL is risky

EXPOSE 8080	#exposes the port. This port should be used in -p 8085:8080 (hostport:internalport) while creating container. This is internal port.

CMD 		#to execute containers we need one command. If we specify multiople cmds in our Dockerfile then only last CMD will work.


-----------------------------------------------------------------------------------------

Example

-----------------------------------------------------------------------------------------

FROM centos
MAINTAINER email@example.com 

# Install dependencies and set up Tomcat
RUN mkdir /opt/tomcat/
WORKDIR /opt/tomcat  
RUN curl -O https://www-eu.apache.org/dist/tomcat/tomcat-8/v8.5.40/bin/apache-tomcat-8.5.40.tar.gz
RUN tar xvfz apache*.tar.gz  # Fixed typo: "xvfr" → "xvfz" (extract gzip)
RUN mv apache-tomcat-8.5.40/* /opt/tomcat/.
RUN yum -y install java-1.8.0-openjdk
RUN java -version

# Deploy sample app
WORKDIR /opt/tomcat/webapps
RUN curl -O -L https://github.com/AKSarav/SampleWebApp/raw/master/dist/SampleWebApp.war

# Expose port and start Tomcat
EXPOSE 8080
CMD ["/opt/tomcat/bin/catalina.sh", "run"]

------------------------------------------------------------------------------------------

Explanation

---------------------------------------------------------------------------------------

Centos OS is the image taken

--> Installing dependencies
Created /opt/tomcat in Centos
Made it as working directory
Downloads tomcat binary
Extracts tomcat tarball
Moves extracted files to /opt/tomcat/
Installs java
Verifies Java installation

-->Deploying sample app
Changing working directory to /opt/tomcat/webapps
Downloads the sample war file from GitHub. Usually we keep war file in Artifactory
Exposes 8080 port
Default command to start Tomcat when the container runs.

----------------------------------------------------------------------------------------

To build the above image

docker build -t my-tomcat-image .  # Build image
docker run -d -p 8081:8080 my-tomcat-container  # Run container

----------------------------------------------------------------------------------------

Instead of building on OS image we can build on tomcat image directly


FROM tomcat:9
MAINTAINER your-email@example.com
COPY ./target/*.war /usr/local/tomcat/webapps/
EXPOSE 8080
CMD CMD ["/opt/tomcat/bin/catalina.sh", "run"]

Note: ["catalina.sh", "run"]  is enough as the path is configured by default in official tomcat:9 $PATH)
      Using base image instead of os image is recommended

--------------------------------------------------------------------------------------

Python Dockerfile

FROM python:3
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
WORKDIR /code
COPY requirements.txt /code/
RUN pip install -r requirements.txt
COPY ./code/
EXPOSE
CMD

--------------------------------------------------------------

Node.js Dockerfile

FROM node:12.18.1
ENV NODE_ENV=production
WORKDIR /app
COPY ["package.json", "package-lock.json*", "./"]
RUN npm install --production
COPY . .
CMD ["node", "server.js"]

--------------------------------------------------------------

Spring Boot Dockerfile

FROM openjdk:8-jdk-alpine
LABEL maintainer="your-email@example.com"	#MAINTAINER is deprecated. Use LABEL
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]

----------------------------------------------------------

Dotnet Dockerfile

FROM mcr.microsoft.com/dotnet/sdk:6.0

RUN useradd -m appuser
WORKDIR /app
COPY *.csproj ./
RUN dotnet restore
COPY . ./
RUN dotnet build -c Release
RUN chmod +x ./entrypoint.sh

EXPOSE 80
USER appuser
CMD ["./entrypoint.sh"]

---------------------------------------------------------

RUN vs ENTRYPOINT

The RUN command executes during the image build phase (docker build) to install dependencies, compile code, or modify the filesystem, creating persistent layers in the Docker image. In contrast, ENTRYPOINT specifies the default executable that runs when the container starts (docker run), defining the primary process (PID 1) and ensuring proper signal handling, though it can be overridden with --entrypoint. Use RUN for setup tasks (e.g., apt-get install) and ENTRYPOINT for the container’s main purpose (e.g., ["java", "-jar", "app.jar"]), while CMD provides default arguments to ENTRYPOINT (or acts as the main command if ENTRYPOINT is omitted). Together, they separate build-time actions from runtime behavior.

