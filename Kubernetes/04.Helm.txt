Helm: The Package Manager for Kubernetes

Core Concept:
Helm is an essential tool that acts as a package manager for Kubernetes, simplifying the deployment and management of complex applications.

The Problem Helm Solves:

    Managing numerous, individual Kubernetes manifest files (YAML) for a single application is tedious and error-prone.
    Helm packages all these resources into a single, versioned, and easily shareable unit called a Chart.

Installation:

    Helm is a command-line tool (CLI) that must be installed on your local machine or a CI/CD server.

    It interacts with your Kubernetes cluster using your kubeconfig file (just like kubectl).

    The latest version is always available on the official Helm GitHub releases page.

Key Components:

    Helm Charts:

        A Chart is a Helm package. It contains all the pre-configured Kubernetes resource definitions (YAML templates) needed to run an application, tool, or service.
        Analogy: It's the Kubernetes equivalent of a Homebrew formula, an APT (.deb), or a YUM (.rpm) package.

    Helm Releases:

        When you deploy a chart, Helm creates a release. This is a specific instance of a chart running in a Kubernetes cluster.
        You can deploy the same chart multiple times, each resulting in a separate release (e.g., my-app-staging, my-app-production).

    Helm Repositories (Repos):

        A Repository is a collection of charts that can be shared. It's a place to store and distribute charts.
        Analogy: It's like npmjs.org for Node.js modules or the Ubuntu package repositories for APT.
        The main public repository is Artifact Hub.

    Values.yaml:

        This is a critical file that allows for customization. It contains configuration parameters that are injected into the chart's templates.

        This separates the application's configuration (values.yaml) from its deployment logic (the chart templates), enabling one chart to be used for different environments (dev, staging, prod) by simply changing the values.


Basic Workflow:

    helm repo add [repository-name] [url] (Add a chart repository)
    helm install [release-name] [chart-name] (Deploy a chart)
    helm upgrade [release-name] [chart-name] (Upgrade a release)
    helm uninstall [release-name] (Remove a release)
    helm list (List deployed releases)


helm install happy-panda bitnami/wordpress 	#Installs the WordPress chart from the bitnami repository, naming the release "happy-panda".
helm install mytomcat stable/tomcat - Installs the tomcat chart from the stable repository, naming the release "mytomcat".
helm install mytomcat1 ./tomcat - Installs the tomcat chart from a local directory (./tomcat), naming the release "mytomcat1".

------------------------------------------------------------------------------------------

ðŸ‘‰Charts
Helm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources. A single chart might be used to deploy something simple, like a memcached pod, or something complex, like a full web app stack with HTTP servers, databases, caches, and so on.

Charts are created as files laid out in a particular directory tree. They can be packaged into versioned archives to be deployed.

If you want to download and look at the files for a published chart, without installing it, you can do so with helm pull chartrepo/chartname.

helm pull stable/tomcat
helm pull stable/mysql

helm install mydb ./MySQL


--------------------------------------------------------------------------------

ðŸ‘‰The Chart File Structure

A chart is organized as a collection of files inside of a directory. The directory name is the name of the chart (without versioning information). Thus, a chart describing WordPress would be stored in a wordpress/ directory.

Inside of this directory, Helm will expect a structure that matches this:

wordpress/
  Chart.yaml          # A YAML file containing information about the chart
  LICENSE             # OPTIONAL: A plain text file containing the license for the chart
  README.md           # OPTIONAL: A human-readable README file
  values.yaml         # The default configuration values for this chart
  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file
  charts/             # A directory containing any charts upon which this chart depends.
  crds/               # Custom Resource Definitions
  templates/          # A directory of templates that, when combined with values,
                      # will generate valid Kubernetes manifest files.
  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes

--------------------------------------------------------------------------------

The Chart.yaml file is required for a chart. It contains the following fields:
---------------------------------------------------------------------------------


apiVersion: The chart API version (required)
name: The name of the chart (required)
version: A SemVer 2 version (required)
kubeVersion: A SemVer range of compatible Kubernetes versions (optional)
description: A single-sentence description of this project (optional)
type: The type of the chart (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this projects home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
dependencies: # A list of the chart requirements (optional)
  - name: The name of the chart (nginx)
    version: The version of the chart ("1.2.3")
    repository: (optional) The repository URL ("https://example.com/charts") or alias ("@repo-name")
    condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )
    tags: # (optional)
      - Tags can be used to group charts for enabling/disabling together
    import-values: # (optional)
      - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.
    alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times
maintainers: # (optional)
  - name: The maintainers name (required for each maintainer)
    email: The maintainers email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended.
deprecated: Whether this chart is deprecated (optional, boolean)
annotations:
  example: A list of annotations keyed by name (optional).
------------------------------------------------------------------------------------

In Charts/ directory we keep the dependencies

dependencies:
  - name: apache
    version: 1.2.3
    repository: https://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: https://another.example.com/charts

-------------------------------------------------------------------------------------

ðŸ‘‰Templates and Values

Helm Chart templates are written in the Go template language, with the addition of 50 or so add-on template functions from the Sprig library and a few other specialized functions.

All template files are stored in a chart's templates/ folder. When Helm renders the charts, it will pass every file in that directory through the template engine.

Values for the templates are supplied two ways:

    Chart developers may supply a file called values.yaml inside of a chart. This file can contain default values.
    Chart users may supply a YAML file that contains values. This can be provided on the command line with helm install.

When a user supplies custom values, these values will override the values in the chart's values.yaml file.
--------------------------------------------------------------------------------------
Template Files Example

apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }}
          imagePullPolicy: {{ .Values.pullPolicy }}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{ default "minio" .Values.storage }}

------------------------------------------------------------------------------------

ðŸ”¹Predefined Values

Values that are supplied via a values.yaml file (or via the --set flag) are accessible from the .Values object in a template. But there are other pre-defined pieces of data you can access in your templates.

The following values are pre-defined, are available to every template, and cannot be overridden. As with all values, the names are case sensitive.

    Release.Name: The name of the release (not the chart)
    Release.Namespace: The namespace the chart was released to.
    Release.Service: The service that conducted the release.
    Release.IsUpgrade: This is set to true if the current operation is an upgrade or rollback.
    Release.IsInstall: This is set to true if the current operation is an install.
    Chart: The contents of the Chart.yaml. Thus, the chart version is obtainable as Chart.Version and the maintainers are in Chart.Maintainers.
    Files: A map-like object containing all non-special files in the chart. This will not give you access to templates, but will give you access to additional files that are present (unless they are excluded using .helmignore). Files can be accessed using {{ index .Files "file.name" }} or using the {{.Files.Get name }} function. You can also access the contents of the file as []byte using {{ .Files.GetBytes }}
    Capabilities: A map-like object that contains information about the versions of Kubernetes ({{ .Capabilities.KubeVersion }}) and the supported Kubernetes API versions ({{ .Capabilities.APIVersions.Has "batch/v1" }})

NOTE: Any unknown Chart.yaml fields will be dropped. They will not be accessible inside of the Chart object. Thus, Chart.yaml cannot be used to pass arbitrarily structured data into the template. The values file can be used for that, though.


ðŸ”¹Values files

Considering the template in the previous section, a values.yaml file that supplies the necessary values would look like this:

imageRegistry: "quay.io/deis"
dockerTag: "latest"
pullPolicy: "Always"
storage: "s3"

A values file is formatted in YAML. A chart may include a default values.yaml file. The Helm install command allows a user to override values by supplying additional YAML values:

$ helm install --generate-name --values=myvals.yaml wordpress

helm install mytomcatnew --values=production.yaml stable/tomcat
helm install mytomcatdev --values=development.yaml stable/tomcat

--------------------------------------------------------------------------------

ðŸ‘‰Helm Commands

ðŸ”¹helm create	#create a new chart with the given name
This command creates a chart directory along with the common files and directories used in a chart.

ðŸ”¹helm lint	#examine a chart for possible issues
This command takes a path to a chart and runs a series of tests to verify that the chart is well-formed.

If the linter encounters things that will cause the chart to fail installation, it will emit [ERROR] messages. If it encounters issues that break with convention or recommendation, it will emit [WARNING] messages.

helm lint ./foo



ðŸ”¹helm install

$ helm install -f myvalues.yaml myredis ./redis

or

$ helm install --set name=prod myredis ./redis

or

$ helm install --set-string long_int=1234567890 myredis ./redis

or

$ helm install --set-file my_script=dothings.sh myredis ./redis

or

$ helm install --set-json 'master.sidecars=[{"name":"sidecar","image":"myImage","imagePullPolicy":"Always","ports":[{"name":"portname","containerPort":1234}]}]' myredis ./redis

You can specify the '--values'/'-f' flag multiple times. The priority will be given to the last (right-most) file specified. For example, if both myvalues.yaml and override.yaml contained a key called 'Test', the value set in override.yaml would take precedence:

$ helm install -f myvalues.yaml -f override.yaml  myredis ./redis


helm repo add bitnami https://charts.bitnami.com/bitnami

helm install mytomcat -f prod.yaml bitnami/tomcat

helm uninstall releasename

helm upgrade

$ helm upgrade -f myvalues.yaml -f override.yaml myredis ./redis

$ helm upgrade --set foo=bar --set foo=newbar redis ./redis

Helm Rollback:
helm rollback - roll back a release to a previous revision
helm rollback myredis 3

https://helm.sh/docs/helm/helm_rollback/


Important Helm Charts:

tomcat
mysql
jenkins
prometheus
rabbitmq
redis
mongodb
kafka
grafana
elk
splunk

https://github.com/bitnami/charts.git